import React, {useCallback, useEffect, useMemo, useRef} from 'react';
import {StyleSheet, Text, View, Image, Animated} from 'react-native';
import {useHeaderHeight} from '@react-navigation/stack';
import {RootState} from '@/models/index';
import {connect, ConnectedProps} from 'react-redux';
import {RootStackParamList} from '@/navigator/index';
import {RouteProp} from '@react-navigation/native';
import CorverRight from '@/assets/cover-right.png';
import {BlurView} from '@react-native-community/blur';
import Tab from './Tab';
import {
  NativeViewGestureHandler,
  PanGestureHandler,
  PanGestureHandlerStateChangeEvent,
  State,
  TapGestureHandler,
} from 'react-native-gesture-handler';
import {viewportHeight} from '@/utils/index';

const mapStateToProps = ({album}: RootState) => {
  return {
    summary: album.summary,
    author: album.author,
  };
};

const connector = connect(mapStateToProps);

type ModelState = ConnectedProps<typeof connector>;
interface IProps extends ModelState {
  route: RouteProp<RootStackParamList, 'Album'>;
}
const USE_NATIVE_DRIVER = true;
const HEADER_HEIGHT = 260; // 频道信息头部高度

const Album: React.FC<IProps> = ({dispatch, route, summary, author}) => {
  const headerHeight = useHeaderHeight();
  const RANGE = [-(HEADER_HEIGHT - headerHeight), 0];

  const translateYValue = useRef(0);
  const translateYInterpolateValue = useRef(0);
  const lastScrollYValue = useRef(0);

  const tapRef = useRef<any>(null);
  const panRef = useRef<PanGestureHandler>(null);
  const nativeRef = useRef<NativeViewGestureHandler>(null);

  const dragY = new Animated.Value(0); // 手指拖动的Y轴距离
  const translateYOffset = new Animated.Value(0); // 上一次拖动的Y轴距离
  const lastScrollY = new Animated.Value(0);

  const reverseLastScrollY = Animated.multiply(
    new Animated.Value(-1),
    lastScrollY,
  );
  const translate = Animated.add(
    Animated.add(dragY, reverseLastScrollY),
    translateYOffset,
  );
  const translateY = translate.interpolate({
    inputRange: RANGE,
    outputRange: RANGE,
    extrapolate: 'clamp',
  });

  useEffect(() => {
    const {id} = route.params.item;
    dispatch({
      type: 'album/fetchAlbum',
      payload: {
        id,
      },
    });
    // // 时间函数：作用是推动一个值按照缓动曲线随着时间变化
    // Animated.timing(translateY, {
    //   toValue: -170,
    //   duration: 3000, // 在3秒将translateY有0改为-170
    //   useNativeDriver: true,
    // }).start();
    (translate as Animated.Value).addListener(({value}) => {
      translateYValue.current = value;
    });
    (translateY as Animated.Value).addListener(({value}) => {
      translateYInterpolateValue.current = value;
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [dispatch, route.params.item]);

  // 在手指拖动时一直触发
  // Animated.event 用来映射动画值
  const onGestureEvent = Animated.event(
    [{nativeEvent: {translationY: dragY}}],
    {
      useNativeDriver: USE_NATIVE_DRIVER, // 启动原生动画，性能更好
    },
  );

  // 监听FlatList滚动
  // const onScrollBeginDrag = Animated.event<{contentOffset: {y: number}}>(
  //   [{nativeEvent: {contentOffset: {y: lastScrollY}}}],
  //   {
  //     useNativeDriver: USE_NATIVE_DRIVER,
  //     listener: ({nativeEvent}) => {
  //       lastScrollYValue.current = nativeEvent.contentOffset.y;
  //     },
  //   },
  // );

  // 手势状态发生变化时回调
  const onHandlerStateChange = useCallback(
    ({nativeEvent}: PanGestureHandlerStateChangeEvent) => {
      // 离开之前的上一次状态是活动的
      if (nativeEvent.oldState === State.ACTIVE) {
        let {translationY} = nativeEvent;
        translationY -= lastScrollYValue.current;
        // Animated.Value
        // value
        // offset = value
        translateYOffset.extractOffset();
        translateYOffset.setValue(translationY);
        translateYOffset.flattenOffset();
        // value = value + offset
        dragY.setValue(0);
        let maxDeltaY = 0;
        if (translationY < 0 && translateYValue.current < RANGE[0]) {
          Animated.timing(translateYOffset, {
            toValue: RANGE[0],
            useNativeDriver: USE_NATIVE_DRIVER,
          }).start();
          maxDeltaY = RANGE[1];
        } else if (translationY > 0 && translateYValue.current > RANGE[1]) {
          Animated.timing(translateYOffset, {
            toValue: RANGE[1],
            useNativeDriver: USE_NATIVE_DRIVER,
          }).start();
          maxDeltaY = -RANGE[0];
        } else {
          maxDeltaY = -translateYInterpolateValue.current;
        }
        console.log('translateYInterpolateValue', translateYInterpolateValue);
        console.log('maxDeltaY', maxDeltaY);
        if (tapRef.current) {
          tapRef.current.setNativeProps({
            maxDeltaY,
          });
        }
      }
    },
    [RANGE, dragY, translateYOffset],
  );

  // onItemPress = (item: IAlbum, index: number) => {
  //   const {navigation, dispatch, data} = this.props;
  //   const previousItem: IAlbum = data.list[index - 1];
  //   const nextItem: IAlbum = data.list[index + 1];
  //   let params = {
  //     id: item.id,
  //   };
  //   dispatch({
  //     type: 'player/setState',
  //     payload: {
  //       playList: data.list.map(item => item.id),
  //       currentId: item.id,
  //       previousId: previousItem && previousItem.id,
  //       nextId: nextItem && nextItem.id,
  //     },
  //   });
  //   navigation.navigate('ProgramDetail', params);
  // };

  const renderHeader = useMemo(() => {
    const {title, image} = route.params.item;
    if (!image || !author.avatar) {
      return null;
    }
    return (
      <View style={[styles.header, {paddingTop: headerHeight}]}>
        <Image source={{uri: image}} style={styles.background} />
        <BlurView
          blurType="light"
          blurAmount={5}
          style={StyleSheet.absoluteFillObject}
        />
        <View style={styles.leftView}>
          <Image style={styles.thumbnail} source={{uri: image}} />
          <Image style={styles.coverRight} source={CorverRight} />
        </View>
        <View style={styles.rightView}>
          <Text style={styles.title}>{title}</Text>
          <View style={styles.summary}>
            <Text numberOfLines={1} style={styles.summaryText}>
              {summary}
            </Text>
          </View>
          <View style={styles.author}>
            <Image source={{uri: author.avatar}} style={styles.avatar} />
            <Text style={styles.name}>{author.name}</Text>
          </View>
        </View>
      </View>
    );
  }, [author.avatar, author.name, headerHeight, route.params.item, summary]);

  return (
    <TapGestureHandler maxDeltaY={-RANGE[0]} ref={tapRef}>
      <View style={StyleSheet.absoluteFillObject} pointerEvents="box-none">
        <Animated.View
          style={[
            StyleSheet.absoluteFillObject,
            {transform: [{translateY: translateY}]},
          ]}>
          {/* PanGestureHandler 专门监听拖动手势组件，
    onGestureEvent 在手指触碰时会一直触发 */}
          <PanGestureHandler
            ref={panRef}
            simultaneousHandlers={[tapRef, nativeRef]}
            shouldCancelWhenOutside={false}
            onGestureEvent={onGestureEvent}
            onHandlerStateChange={onHandlerStateChange}>
            <Animated.View>
              {renderHeader}
              <View
                style={[styles.tab, {height: viewportHeight - headerHeight}]}>
                <Tab
                // nativeRef={nativeRef}
                // tapRef={tapRef}
                // panRef={panRef}
                // route={route}
                // onScrollBeginDrag={onScrollBeginDrag}
                // onItemPress={onItemPress}
                />
              </View>
            </Animated.View>
          </PanGestureHandler>
        </Animated.View>
      </View>
    </TapGestureHandler>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    height: HEADER_HEIGHT,
    flexDirection: 'row',
    paddingHorizontal: 20,
    alignItems: 'center',
  },
  background: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: '#eee',
  },
  leftView: {
    marginRight: 26,
  },
  thumbnail: {
    width: 98,
    height: 98,
    borderColor: '#fff',
    borderWidth: StyleSheet.hairlineWidth,
    borderRadius: 8,
    backgroundColor: '#fff',
  },
  coverRight: {
    height: 98,
    position: 'absolute',
    right: -23,
    resizeMode: 'contain',
  },
  rightView: {
    flex: 1,
  },
  title: {
    color: '#fff',
    fontSize: 18,
    fontWeight: '900',
  },
  summary: {
    backgroundColor: 'rgba(0,0,0,0.3)',
    padding: 10,
    marginVertical: 10,
    borderRadius: 4,
  },
  summaryText: {
    color: '#fff',
  },
  author: {
    alignItems: 'center',
    flexDirection: 'row',
  },
  avatar: {
    height: 26,
    width: 26,
    borderRadius: 13,
    marginRight: 8,
  },
  name: {
    color: '#fff',
  },
  tab: {
    backgroundColor: '#fff',
  },
});

export default connector(Album);
